--Collection-

-What is a collection?

*A collection is nice because we can put more than one value in it and carry them all around in one convenient package

*We have a bunch of values in a single "variable"

*We do this by having more than one place "in" the variable

*We have ways of finding the different places in the variable


-What is not a "Collection"?

*Most of our "variables" have one value in them - when we put a new value in the "variable" - the old values is overwritten

$ python

x = 2

x = 4

print(x)

-A Story of Two Collections-

*List
   *A linear collection of values that say in order ( like pringles)
*Dictionary
   *A "bag" of values, each with its own label ( its messy like a wallet)

-Dictionaries- http://en.wikipedia.org/wiki/Associative_array

Dictionaries are like if we put in each thing stickers 

*Is like a bagpack but you have label them

-Dictionaries-

*Dictionaries are Python's most powrful data collection

*Dictionaries allow us to do fast database-like operations in Python

*Dictionaries have different names in different languages

	*Associate Arrays - Perl/PHP

	*Properties or Map or HashMap - Java

	*Property Bag - C#/.Net

*Lists "index" their entries based on the position in the list

*"Dictionaries" are like bags - no order

*So we "index" the things we put in the "dictionary with a "lookup tag"

 
purse = dict()
purse['money'] = 12 ->money(12)
purse['candy'] = 3->candy(3)
purse['tissues'] = 75-> tissues(75)
print(purse)
print(purse['candy'])

purse['candy'] = purse['candy'] + 2 -> make 3 to 5 in candy
print(purse)

/////////////////////////////////////
 
{'tissues': 75, 'candy': 3, 'money': 12}
3
{'tissues': 75, 'candy': 5, 'money': 12}

-Comparing Lists and Dictionaries-

*"Dictionaries" are like "lists" except tha they use "keys" instead of numbers to look up "values"



print('\n','Lists')
lst = list()
lst.append(21)
lst.append(183)
print(lst)
lst[0] = 23
print(lst)

print('\n','Dictionaries')
ddd = dict()
ddd['age'] = 21
ddd['course'] = 182
print(ddd)
ddd['age'] = 23
print(ddd)

//////////////////////////////////

    List

Key  Value

[0]  21

[1]  183

    Dictionary

Key        Value

['course'] 182  
                       ddd
['age']    21


-Dictionary Literas(Constants)-

*Dictionary literals use curly braces and have a list of key: value pairs

*You can make an "empty dictionary" using empty curly braces

--Dictionary Literals (Constants)-

*Dictionary literals use curly braces and have a lis tof key: value pairs

*You can make an "empty dictionary" using empty curl braces

jjj = {'chuck' : 1,  'fred' : 42, 'jan' : 100}
print(jjj)

ooo= { } #to put the curly braces is shortuc to call the variable dict()
print(ooo)

--Counting--

--Most Common Name?-

-Counting an histagram/ how many times happened.

-one piece of data at the time and in each time in every content to starting in time.

What is the common name?

marquard cwen cwen
 zhen  marquard zhen

csev  zhen csev
           marquard
zhen csev  zhen

*For humans is easy and you put in a pper and make takemarks and is have to be done

*And that is how we are going to use dictionaries to do that

-Many-Counters-with-a-Dictionary-

One common use of dictionaries is "counting" how often we "see" something



ccc = dict()
ccc['csev'] = 1
ccc['cwen'] = 1
print(ccc)

ccc['cwen'] = ccc['cwen'] + 1

print(ccc)

//////////////////////

key    value

csev  III
cwen  II

*We could extend the dictionary by adding more numbers

-Dictionary-TRacebacks-

* It is an "error" to reference a key which is not in the dictionary 

*We can use the "in" operator to see if a key is in the dictionary

ccc = dict() --> 

print(ccc['csev']) --> blows operator

'csev' in ccc --> if csev is in ccc as result is False and we could avoid the traceback

-When we see a new name--

*When we encounter a new name, we need to add a new entry in the "dictionary" and if this the second or later time we have seen the "name", we simply add one to the count in the "dictionary" under that "name"


counts = dict() 
names = ['csev', 'cwen', 'csev', 'zqian', 'cwen']
for name in names: --> loop through all the list
    if name not in counts: --> if the name is not in the dictionary already is going to set and be 1
        counts[name] = 1
    else: -> if not --> will got the old value and counts the name and will add 1 to it
        counts[name] = counts[name] + 1
print(counts) --> and the end of the loop we have the count dictionary or the histogram we are looking for.

/////////////////////////////

{'csev': 2, 'zqian': 1, 'cwen': 2}

-The "get" method for dictionaries-

The pattern of checking to see if a "key" is already in a dictionary and assuming a default value if the "key" is not there is so common that there is a "method" called "get()" that does this for us

Default value if key does not exist (and no Traceback)


if name in counts: -< 
    x = counts[name] -> retrive the value
else:
    x = 0 --> the default that is not right there

x = counts.get(name, 0) -->counts(dictionary).gets(method) of the default value(name) [ without not traceback)

#Collapsing will become an idiom 


--Simplified counting with get()--

We can use get() and provide a default value of zero when the key is not yet in the dictionary - and then just add one

*Its thanks to the idiom that we could get through the dictionaries and adding one to them


counts = dict()
names = ['csev', 'cwen', 'csev', 'zqian', 'cwen']
for name in names : --> name will be through the 5 values
    counts[name] = counts.get(name, 0) + 1 --> if name will be 1 and 1 + 1 = 2 and if is not will be 0 + 1 = 1; so the first time that an elemnt appear the count will be 1 not 0 so what that makes the "0" default; and "0" is a common default like an histagram
print(counts)

//////////////////////////////

Simplified counting with get()
{'zqian': 1, 'cwen': 2, 'csev': 2}

*This pattern is a really good pattern to know

--Counting words in text--

Writing programs (programming) is a very creative skill that requires a combination of logical thinking and problem-solving abilities. It involves crafting elegant solutions to complex problems, and requires a deep understanding of various programming languages, frameworks, and tools. The process of programming often involves iterating, testing, and refining code until it works as intended, and the end result can be a beautifully designed application or tool that solves real-world problems. Ultimately, programming is a highly rewarding and fulfilling skill that allows individuals to bring their ideas to life and make a positive impact on the world. So, mastering programming skills can lead to great career opportunities and personal growth.


We are surrounded by a vast and complex world that is full of wonder, diversity, and opportunity. From the natural beauty of our planet to the technological advancements that shape our daily lives, there is no shortage of things to explore and discover. Whether it's the cultures, languages, and traditions of different people, or the scientific and technological breakthroughs that are constantly transforming our world, there is always something new to learn and experience. So, it's up to us to embrace the endless possibilities that surround us and make the most of our time on this earth.


Our computers can be incredibly powerful tools for increasing productivity and enhancing creativity, but they can also be a source of mind-numbing distraction and overstimulation. With the endless stream of notifications, emails, and social media updates vying for our attention, it's easy to get caught up in the endless cycle of digital noise and lose sight of our priorities. However, with a little discipline and focus, we can harness the power of our computers to achieve our goals and make a positive impact on the world. By prioritizing deep work, limiting distractions, and using technology intentionally, we can cultivate a more productive and fulfilling relationship with our digital devices.

--Couting pattern--

counts = dict() #We create the variable dictionary

print('Enter a line of text:') #Printing the  input
line = input('') get the input 

words = line.split() #split the chain of the input

print('Words:', words) #print the words in each string

print('Counting...')
for words in words:
    counts[word] = counts.get(word,0) + 1# will count[words] = will go through the idiom adding 1 to an existing entry
print('Counts', counts) #And printing that out

*The general pattern to count the words in a line of text is to split the line into words, then loop through the words and use a dictionary to track the count of each word independently.

---Enhacement of the file ----

counts = dict() --> we create the dictionary

line = input('Enter a line of text:') --> we enter the text
words = line.split() ---> we split each word of the variable 

print("Words:", words) --> we print each word 
print('\nCounting...')

for word in words: --> loop through all the worlds given for the user
    counts[word] = counts.get(word,0) + 1 --> enter the variable dictionary inside the word and will be use the method get like a dictionary counting each word 
print('Counts', counts) --> will print the dictionary counting in each variable (word,0..1...so on)

/////////////////

Enter a line of text:

the clown ran after the car and the car ran

Counting....

Counts{and:3...}

--Define Loops and Dictionaries--

Even thorugh dictionaries are not stored in order, we can write a for loop that goes through all the entries in a dictionary - actually it goes through all the entries in a dictionary - actually it goes through all of the keys in the dictionary and looks up the values.

counts = { 'chuck': 1, 'fred': 42, 'jan': 100}

for key in counts:
    print(key, counts[key])

...
...
jan 100
chuck 1
fred 42

--Retrieving lists of keys and values --

You can get a list of keys, values, or items(both) from a dictionary


jjj = { 'chuck' :1, 'fred': 42, 'jan':100 }
print(list(jjj)) #turning this in a list
print(jjj.keys()) #getting the keys like a list
print(jjj.values()) # getting the values as list
print(jjj.items()) #print item and is like a tuple

///////////////////////
['jan', 'chuck', 'fred']
(['jan', 'chuck', 'fred'])
([100, 1, 42])
([('jan', 100), ('chuck', 1), ('fred', 42)])
      0  1          1     1      1   2

--Bonus: Two Iteration Variables--

*We loop through the key-value pairs in a dictionary using *two* iteration varaibles

*Each iteration, the first variable is the key and the second variable is the corresponding value for the key

jjj = { 'chuck' :1, 'fred': 42, 'jan':100 }

for aaa, bbb in jjj.items(): # to understand this is easy like for items, keys in dictionary.items() like a syntax.
    print(aaa, bbb)

////////// words ///////////

name = input('Enter file:') # to use the name of the file
handle = open(name) # we open the name of the file

counts = dict() # we make an empty dictionary
for line in handle: # line is going to be line by line by line
    words = line.split() #we split each line into words
    for word in words: #we are going to word into wordsto iterate each word of the line
        counts[words] = counts.get(word,0) + 1 #we are going to do this histogram using get 

#technically we have a nested loop to split each line of the file and the iter loop will count of each list
////////////////////////////////
#not we want to find the largest one and to find the  greatest value of the dictionary
bigcount = None #we don't know what is the big count is
bigword = None #we don't know what is the bigword
for word, count in counts.items(): #we are going to the dictionary keys and values of the counts
    if bigcount is None or count > bigcount: # if bigcount is none or less than bigcount
        bigword = word  
        bigcount = count
# the max loop what is inside recording them

print(bigword, bigcount)

/////////////////////////
$python words.py
Enter file: words.txt the 7

-- Summary --

*What is a collection?

*Lists versus Dictionaries

*Dictionary constants


*The most common word


*Using the get() method


*Hashing, and lack of order

*Writing dicitionary loops

*Sneak peek:tuples


*Sorting dictionaries
